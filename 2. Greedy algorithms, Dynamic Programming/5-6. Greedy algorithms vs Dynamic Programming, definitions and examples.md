## Введение: Жадные алгоритмы и динамическое программирование

Начнём с определений.

- **Жадный алгоритм** — это алгоритм совершающий на каждом шаге локально-оптимальный выбор в надежде найти глобально-оптимальное решение. Что это значит? Жадный алгоритм выбираем то, что кажется лучшим прямо сейчас, надеясь, что в итоге это приведёт к глобально оптимальному решению. Это как если вы идёте по дороге и на каждом перекрёстке выбираете путь, который выглядит шире или красивее, в надежде, что он приведёт вас к цели быстрее всех.
- **Динамическое программирование (ДП)** — это другой подход, более систематический. Он разбивает задачу на подзадачи и решает их поэтапно. Обычно метод ДП включает четыре шага:
  1. **Выделение подзадач**: на какие части можно разбить большую задачу?
  2. **Нахождение рекуррентной формулы**: Связать эти подзадачи между собой рекуррентным соотношением.
  3. **Решение элементарных случаев**: Элементарные случаи - это те случаи в которых рекуррентную формулу использовать не выйдет и на основе этих элементарных случаев и строятся остальные значения (например в случае нахождения чисел фибоначи элементарными являются первые 2 значения $F_0=F_1=1$, так как их нельзя найти формулой и их значения нужны для построения всей последовательности)
  4. **Использование мемоизации**: сохранение промежуточных результатов, чтобы не пересчитывать их заново.

И жадные алгоритмы, и ДП используются для решения задач оптимизации, где нужно найти максимум или минимум какой-то величины из всех возможных случаев или же найти количество возможных случаев. Некоторые задачи можно решить жадным алгоритмом, некоторые — только ДП.

## Минимальный путь в таблице

Ознакомьтесь с задачей "[Минимальный путь в таблице](https://acmp.ru/index.asp?main=task&id_task=120)" и далее увидим поведение жадного алгоритма в этой задаче и также построим решение динамическим программированием.

## Подход 1: Жадный алгоритм

Что первое приходит на ум? Попробуем жадный алгоритм. Как он работает? На каждом шаге мы смотрим на соседние клетки — справа и снизу — и идём туда, где число меньше. Это локально оптимальное решение. Давайте применим это к нашей задаче.

Рассмотрим на втором примере приведенном в задаче, т.е. на матрице размера $5 \times 5$ с содержанием



$$
\begin{array}{r|ccccccc}
\text{Индексы} & 0 & 1 & 2 & 3 & 4\\
\hline
0 & 1 & 1 & 1 & 1 & 1\\
1 & 3 &100&100&100&100\\
2 & 1 & 1 & 1 & 1 & 1 \\
3 & 2 & 2 & 2 & 2 & 1\\
4 & 1 & 1 & 1 & 1 & 1\\
\end{array}
$$

### Правила движения:

Начинаем с верхнего левого угла (0,0). <br>
На каждом шаге выбираем минимум из доступных соседей (вправо и вниз).

<table>
    <thead>
        <tr>
            <th>Шаг</th>
            <th>Позиция</th>
            <th>Выбор соседа</th>
            <th>Новый путь</th>
            <th>Сумма</th>
        </tr>
    </thead>
    <tbody>
        <tr><td>1</td><td>(0,0) = 1</td><td>&rarr; (0,1) = 1</td><td>(0,0) → (0,1)</td><td>1</td></tr>
        <tr><td>2</td><td>(0,1) = 1</td><td>&rarr; (0,2) = 1</td><td>(0,0) → (0,1) → (0,2)</td><td>2</td></tr>
        <tr><td>3</td><td>(0,2) = 1</td><td>&rarr; (0,3) = 1</td><td>(0,0) → (0,1) → (0,2) → (0,3)</td><td>3</td></tr>
        <tr><td>4</td><td>(0,3) = 1</td><td>&rarr; (0,4) = 1</td><td>(0,0) → (0,1) → (0,2) → (0,3) → (0,4)</td><td>4</td></tr>
        <tr><td>5</td><td>(0,4) = 1</td><td>&darr; (1,4) = 100</td><td>(0,0) → ... → (0,4) → (1,4)</td><td>104</td></tr>
        <tr><td>6</td><td>(1,4) = 100</td><td>&darr; (2,4) = 1</td><td>(0,0) → ... → (1,4) → (2,4)</td><td>105</td></tr>
        <tr><td>7</td><td>(2,4) = 1</td><td>&darr; (3,4) = 1</td><td>(0,0) → ... → (2,4) → (3,4)</td><td>106</td></tr>
        <tr><td>8</td><td>(3,4) = 1</td><td>&darr; (4,4) = 1</td><td>(0,0) → ... → (3,4) → (4,4)</td><td>107</td></tr>
        <tr><td>9</td><td>(4,4) = 1</td><td> ∅ </td><td>(0,0) → ... → (3,4) → (4,4)</td><td>108</td></tr>
    </tbody>
</table>


### Итог:

Жадный алгоритм выбрал путь через (1,4) с огромным весом 100, вместо того чтобы заранее пойти вниз, где суммарный вес был бы меньше.

#### Ответ алгоритма:
(0,0) → (0,1) → (0,2) → (0,3) → (0,4) → (1,4) → (2,4) → (3,4) → (4,4)<br>
Сумма = 1 + 1 + 1 + 1 + 1 + 100 + 1 + 1 + 1 = 108

#### Лучший путь:
(0,0) → (1,0) → (2,0) → (2,1) → (2,2) → (2,3) → (2,4) → (3,4) → (4,4)<br>
Сумма = 1 + 3 + 1 + 1 + 1 + 1 + 1 + 1 + 1 = 11

Жадный алгоритм плохо справляется с такими случаями, так как принимает решения, не оценивая их долгосрочные последствия.

## Подход 2: Динамическое программирование

Раз жадный алгоритм нас подвёл, давайте попробуем ДП. Мы уже сказали, что у метода четыре шага. Пройдём их по порядку.

### Шаг 0: Выделение подзадач
На какие подзадачи можно разбить задачу? Мы хотим найти максимальную сумму пути от `(0,0)` до `(n-1, m-1)`. А что если мы найдём максимальную сумму пути до каждой клетки `(i,j)`? Например:
- До `(0,0)` — это просто число в этой клетке.
- До `(0,1)` — путь только вправо.
- До `(1,0)` — путь только вниз.

**Подзадача**: для каждой клетки `(i,j)` найти максимальную сумму пути от `(0,0)` до `(i,j)`, двигаясь только вниз или направо. Назовём это `T(i,j)` — максимальная сумма на лучшем пути до клетки `(i,j)`.

Как охарактеризовать эти подзадачи? Каждая подзадача — это матрица меньшего размера, заканчивающаяся в клетке `(i,j)`. Например, матрица `1×1` — это `(0,0)`, матрица `2×3` — это от `(0,0)` до `(1,2)`. Мы будем обозначать размер через координаты нижнего правого угла: `n` — строки, `m` — столбцы. Итак, `T(n,m)` — это решение для матрицы размера `n×m`.

### Шаг 1: Нахождение рекуррентной формулы
Теперь свяжем подзадачи. Если мы стоим в клетке `(i,j)`, откуда мы могли прийти?
- Слева, из `(i, j-1)`.
- Сверху, из `(i-1, j)`.

Если мы пришли слева, то максимальная сумма до `(i,j)` — это `T(i, j-1)` плюс число в текущей клетке `matrix[i][j]`. Если сверху — то `T(i-1, j) + matrix[i][j]`. Какой путь лучше? Тот, что больше. Значит: `T(i,j) = max(T(i, j-1), T(i-1, j)) + matrix[i][j]`

Например, для матрицы: 
```cpp
1 2 
3 4
```

- Если мы в `(1,1)`, то либо слева (`T(1,0) + 4`), либо сверху (`T(0,1) + 4`). Берём максимум.

Это наше рекуррентное соотношение. Мы нашли связь между подзадачами — половина дела сделана!

### Шаг 2: Элементарные случаи
Теперь определим базовые случаи. Что такое элементарный случай? Это ситуация, когда наша формула не работает, потому что одного из вариантов (слева или сверху) нет.

`T(0,j) = T(0, j-1) + matrix[0][j]`

А для `(0,0)`: `T(0,0) = matrix[0][0]`.
- **Первый столбец (j=0):** Справа прийти нельзя, только сверху: `T(i,0) = T(i-1, 0) + matrix[i][0]`
`
Пример:`
```cpp
1 2 3 
4 5 6
```

- `T(0,0) = 1`
- `T(0,1) = 1 + 2 = 3`
- `T(0,2) = 3 + 3 = 6`
- `T(1,0) = 1 + 4 = 5`

Это наши отправные точки. А что если у нас отрицательное число? Формула всё равно работает, мы просто суммируем числа по пути. Никаких дополнительных условий не нужно — глобально вверх идти нельзя, это ограничение задачи.

### Шаг 3: Мемоизация и решение задачи
Если мы остановимся на шагах 0, 1 и 2, это будет обычная рекурсия. Мы напишем функцию `T(i,j)`, которая рекурсивно вызывает себя для `(i-1,j)` и `(i,j-1)`. Но в чём проблема? Без мемоизации это превратится в brute force — перебор всех путей.

Почему? Представьте:
- Для `T(n,m)` мы вычисляем `T(n-1,m)` и `T(n,m-1)`.
- Для `T(n-1,m)` вычисляем `T(n-2,m)` и `T(n-1,m-1)`.
- Для `T(n,m-1)` тоже вычисляем `T(n-1,m-1)`.

`T(n-1,m-1)` считается дважды! А если матрица большая, одни и те же значения будут пересчитываться экспоненциально много раз. Всего путей от `(0,0)` до `(n-1,m-1)` — это `2^(n+m-2)`, потому что на каждом из `n+m-2` шагов (n вниз, m вправо) два выбора. Это ужасно медленно.

**Мемоизация** решает эту проблему. Мы запоминаем уже вычисленные значения в таблице `T`. У нас два параметра — `i` и `j`, значит, нужна двумерная матрица `T[n][m]`. Заполняем её один раз и используем сохранённые результаты.

#### Пример с меморизацией
Матрица:
```cpp
1 0 0 
1 0 10 
1 10 0
```

- **Элементарные случаи:**
  - `T[0][0] = 1`
  - `T[0][1] = 1 + 0 = 1`
  - `T[0][2] = 1 + 0 = 1`
  - `T[1][0] = 1 + 1 = 2`
  - `T[2][0] = 2 + 1 = 3`
  
  Заполнение первой строки и столбца заняло `O(n + m)` действий.

- **Заполнение остальной таблицы:**
  - `T[1][1] = max(T[0][1], T[1][0]) + 0 = max(1, 2) + 0 = 2`
  - `T[1][2] = max(T[0][2], T[1][1]) + 10 = max(1, 2) + 10 = 12`
  - `T[2][1] = max(T[1][1], T[2][0]) + 10 = max(2, 3) + 10 = 13`
  - `T[2][2] = max(T[1][2], T[2][1]) + 0 = max(12, 13) + 0 = 13`

Итоговая таблица:
```cpp
1 1 1 
2 2 12 
3 13 13
```

Ответ: `T[2][2] = 13`. Путь: `1 → 1 → 10`.

- **Сложность:** Заполнение таблицы — два цикла `for i=1 to n-1` и `for j=1 to m-1`, итого `O(n·m)` операций. Доп. память — `O(n·m)` для таблицы `T`.

Сравните: без мемоизации — `O(2^(n+m))`, с мемоизацией — `O(n·m)`. Разница колоссальная!

## Дополнительный пример: Числа Фибоначчи

Давайте разберём ещё один пример — вычисление чисел Фибоначчи. Это проще, но отлично показывает суть ДП.

### Постановка задачи
Найти n-е число Фибоначчи: `F(0) = 1`, `F(1) = 1`, `F(n) = F(n-1) + F(n-2)` для `n ≥ 2`.

### Шаги ДП
1. **Подзадачи:** Найти `F(k)` для всех `k < n`.
2. **Рекуррентная формула:** `F(n) = F(n-1) + F(n-2)`.
3. **Элементарные случаи:** `F(0) = 1`, `F(1) = 1`.

#### Без мемоизации
Рекурсия:
```cpp
int fib(int n) {
    if (n == 0 || n == 1) {
        return 1;
    }
    return fib(n - 1) + fib(n - 2);
}
```

Сложность — экспоненциальная, примерно O(φ^n), где φ = (1 + √5)/2 ≈ 1.618 (золотое сечение). Почему? Для F(n) считаем F(n-1) и F(n-2), для F(n-1) — F(n-2) и F(n-3) и т.д. Число вызовов растёт как число Фибоначчи.

#### С меморизацией

Используем массив:
```cpp
long long fib(int n) {
    std::vector<long long> f(n + 1, 0);
    
    f[0] = 1;
    f[1] = 1;
    
    for (int i = 2; i <= n; i++) {
        f[i] = f[i - 1] + f[i - 2];
    }
    
    return f[n];
}
```
- Сложность: O(n) (один цикл).
- Память: O(n) (массив).

#### Оптимизация памяти

Можно обойтись без массива, храня только две переменные:
```cpp
long long fib(int n) {
    long long prev = 1, curr = 1;
    for (int i = 2; i <= n; i++) {
        long long next = prev + curr;
        prev = curr;
        curr = next;
    }
    return curr;
}
```
- Сложность: O(n).
- Память: O(1).

## Дополнительный пример: Нахождение биномиального коэффициента $C(n,k)$

### Постановка задачи
Дано два неотрицательных целых числа $n$ и $k$, где $0 \leq k \leq n$. Необходимо найти биномиальный коэффициент $C(n,k)$, который определяется как:

$$
C(n,k) = \frac{n!}{k!(n-k)!}
$$

Прямое вычисление через факториалы может привести к переполнению даже для небольших $n$ (например, $15!$ не помещается в `int`). Поэтому используем динамическое программирование.

### Шаги ДП

#### Шаг 0: Выделение подзадач
Для нахождения $C(n,k)$ вычисляем $C(m,p)$ для всех $m \leq n$ и $p \leq k$. Подзадача: найти $C(m,p)$.

#### Шаг 1: Нахождение рекуррентной формулы
Биномиальный коэффициент удовлетворяет соотношению:
$$
C(m,p) = C(m-1,p-1) + C(m-1,p)
$$
#### Шаг 2: Элементарные случаи
- $C(m,0) = 1$
- $C(m,m) = 1$
- Если $p > m$, то $C(m,p) = 0$.

#### Шаг 3: Мемоизация
Используем таблицу $C[m][p]$. Заполняем её итеративно:
- $C[i][0] = 1$ для всех $i$.
- Для $i$ от 1 до $n$, для $j$ от 1 до $\min(i,k)$:
$$
  C[i][j] = C[i-1][j-1] + C[i-1][j]
$$

#### Оптимизация: $C(n,k) = C(n,n-k)$
Если $n-k < k$, заменяем $k$ на $n-k$, вычисляя $C(n, \min(k,n-k))$.

#### Оптимизация памяти
Можно хранить только одну строку, обновляя её справа налево, что уменьшает память до $O(\min(k,n-k))$.

### Пример: Треугольник Паскаля
Для $n$ от 0 до 6:
$$
\begin{array}{r|ccccccc}
n \backslash k & 0 & 1 & 2 & 3 & 4 & 5 & 6 \\
\hline
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 \\
2 & 1 & 2 & 1 & 0 & 0 & 0 & 0 \\
3 & 1 & 3 & 3 & 1 & 0 & 0 & 0 \\
4 & 1 & 4 & 6 & 4 & 1 & 0 & 0 \\
5 & 1 & 5 & 10 & 10 & 5 & 1 & 0 \\
6 & 1 & 6 & 15 & 20 & 15 & 6 & 1 \\
\end{array}
$$

### Реализация на C++ (с оптимизацией памяти)

```cpp
#include <iostream>
#include <vector>

long long binomial(int n, int k) {
    k = std::min(k, n - k);
    std::vector<long long> C(k + 1, 0);
    C[0] = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = std::min(i, k); j > 0; j--) {
            C[j] = C[j-1] + C[j];
        }
    }
    return C[k];
}

int main() {
    int n, k;
    std::cout << "Enter n and k: ";
    std::cin >> n >> k;
    if (n < 0 || k < 0 || k > n) {
        std::cout << "Invalid input: ensure 0 <= k <= n and n >= 0." << std::endl;
        return 1;
    }
    std::cout << "C(" << n << "," << k << ") = " << binomial(n, k) << std::endl;
    return 0;
}
```

- **Сложность:** $( O(n \cdot \min(k, n-k)) )$ по времени, $( O(\min(k, n-k)) )$ по памяти.