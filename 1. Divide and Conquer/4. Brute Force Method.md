# Генерация всех подмножеств множества: Итеративный и Рекурсивный методы

## 1. Итеративный метод (Битовая маска)

### Описание метода

Итеративный подход использует **битовое представление** для генерации всех подмножеств множества. Каждое подмножество кодируется последовательностью нулей и единиц, где `1` означает, что элемент включён, а `0` - что нет.

Пример обхода по всем подмножествам множества размера 3 приведен ниже:

| Предыдущее состояние | Следующее состояние |
| -------------------- | ------------------- |
| `{0, 0, 0}`          | `{1, 0, 0}`         |
| `{1, 0, 0}`          | `{0, 1, 0}`         |
| `{0, 1, 0}`          | `{1, 1, 0}`         |
| `{1, 1, 0}`          | `{0, 0, 1}`         |
| `{0, 0, 1}`          | `{1, 0, 1}`         |
| `{1, 0, 1}`          | `{0, 1, 1}`         |
| `{0, 1, 1}`          | `{1, 1, 1}`         |
| `{1, 1, 1}`          | (Останов)           |

Как можем видеть мы хотим из пустого подмножества дойти до подмножества, которое содержит все элементы, на каждом шаге битово инкрементируя наше бинарное представление подмножества.

```cpp
#include <iostream>
#include <vector>

void printAllSubsets(const std::vector<std::string>& set)
{
    // Вектор из нулей и единиц - битовое представление подмножества.
    std::vector<int> subsetRepresentation(set.size(), 0);

    // Флаг обратится в false, если вектор выше будет состоять лишь из единиц.
    bool flag = true;

    while (flag)
    {
        //------------- Вывод текущего подмножества -------------
        std::cout << "{ ";
        bool first = true;
        for (size_t i = 0; i < set.size(); ++i)
        {
            if (subsetRepresentation[i] == 1)
            {
                if (!first) std::cout << ", ";
                std::cout << set[i];
                first = false;
            }
        }
        std::cout << " }" << std::endl;
        //--------------------------------------------------------

        
        //---- Битовое инкрементирование subsetRepresentation ----
        bool found = false;
        for (size_t i = 0; i < set.size(); ++i)
        {
            if (subsetRepresentation[i] == 0)
            {
                subsetRepresentation[i] = 1;
                found = true;
                break;
            }
            else
            {
                subsetRepresentation[i] = 0;
            }
        }
        //--------------------------------------------------------

        if (!found)
            flag = false;
    }
}

int main()
{
    std::vector<std::string> set = {"A", "B", "C"};
    printAllSubsets(set);
    return 0;
}

```
- Мы ищем первый `0` слева направо, превращаем его в `1`, а всё, что слева от него, обнуляем.
- Если subsetRepresentation полностью состоит из единиц, значит, перебрали всё → `flag = false`, завершаем работу.

### Временная сложность

Общее число подмножеств множества из `n` элементов равно $2^n$. Каждый вызов `while`-цикла выполняет O(n) операций (проход по массиву). Следовательно:
- **Основная сложность:** $O(n * 2^n)$
- **Дополнительная сложность (память):** $O(n)$ (для хранения текущего состояния подмножества)

---

## 2. Рекурсивный метод (Backtracking)

### Описание метода

Этот метод использует *рекурсию* для генерации подмножеств. На каждом шаге алгоритм делает выбор: включить текущий элемент в подмножество или пропустить его. <br>

В данной имплементации рекурсивная функция получает 3 аргумента:
1. `set` - то множество, через все подмножества которого нужно пройти.

2. `subset` - В отличае от итеративной имплементации, подмножество не нуждается в бинарном представлении, а хранится в памяти непосредственно и рекурсивно передается функции через этот аргумент.<br>

3. `index` - индекс текущего элемента, для которого рассматриваются 2 случая: включен ли данный элемент в подмножество или нет.


```cpp
#include <iostream>
#include <vector>

void generateSubsets(const std::vector<std::string>& set, std::vector<std::string>& subset, size_t index)
{
    if (index == set.size())
    {
        //------------- Вывод текущего подмножества -------------
        std::cout << "{ ";
        for (size_t i = 0; i < subset.size(); ++i)
        {
            if (i > 0)
                std::cout << ", ";
            std::cout << subset[i];
        }
        std::cout << " }" << std::endl;
        //--------------------------------------------------------

        return;
    }
    
    // set[index] не включен в subset.
    generateSubsets(set, subset, index + 1);
    
    // set[index] включет в subset.
    subset.push_back(set[index]);
    generateSubsets(set, subset, index + 1);
    
    // Необходимо убрать добавленный set[index] из subset.
    subset.pop_back();
}

int main()
{
    std::vector<std::string> set = {"A", "B", "C"};
    std::vector<std::string> subset;
    generateSubsets(set, subset, 0);
    return 0;
}
```

### Временная сложность

И в итеративном и в рекурсивном случаях алгоритм проходит по всем возможным подмножествам данного множества, их число - $2^n$,
И для каждого из этих подмножеств совершает $O(n)$ действий. Таким образом имеем следующие сложности:

- **Основная сложность:** $O(n \cdot 2^n)$
- **Дополнительная сложность (память):** $O(n)$ (из-за глубины рекурсии и хранения текущего подмножества)

---
## 3. Задачка "Лесенка"

Теперь же используем метод полного перебора для решения конкретной задачи, а именно - [Задачи Лесенки](https://acmp.ru/index.asp?main=task&id_task=16).

```cpp
#include <iostream>
 
int staircaseHelper(int n, int maxElementsOnThisLevel)
{
   if (n < 0)
      return 0;
 
   if (n == 0)
      return 1;
 
   int count = 0;
   for (int i = 0; i <= maxElementsOnThisLevel; ++i)
   {
      count += staircaseHelper(n - i, i - 1);
   }
 
   return count;
}
 
int staircase(int n)
{
   return staircaseHelper(n, n);
}
 
int main()
{
   int n;
   std::cin >> n;
   std::cout << staircase(n);
}
```

### Объяснение решения

#### Функция `staircaseHelper(int n, int maxElementsOnThisLevel)`

#### Аргументы:
- `n` — сколько кубиков осталось распределить.
- `maxElementsOnThisLevel` — максимальное количество кубиков, которое можно положить в текущий уровень.

#### Базовые случаи:
- Если `n < 0` — недопустимая конфигурация → вернуть `0`.
- Если `n == 0` — мы нашли корректную лесенку → вернуть `1`.

#### Рекурсия:
- Перебираем количество кубиков `i` для текущего уровня (`i <= maxElementsOnThisLevel`).
- Уменьшаем `n` на `i` и вызываем `staircaseHelper(n - i, i - 1)`, где `i - 1` гарантирует, что следующий уровень будет **меньше** текущего.

#### Функция `staircase(int n)`

- Просто вызывает `staircaseHelper(n, n)`, где `n` — это начальное число кубиков, а `n` также является изначально допустимым максимальным размером первого уровня.
- Существует лишь для удобства, только чтобы принимать 1 аргумент, а не 2.


## 1. Жадный алгоритм

- **Определение:** Жадный алгоритм – это стратегия, при которой на каждом шаге выбирается локально оптимальное решение в надежде, что итоговое решение будет глобально оптимальным. Иными словами, на каждой итерации делается лучший выбор из доступных в данный момент, не перерассматривая решения позже.
    
- **Решение задачи акций Bread Pitt жадным алгоритмом:** 
    
    ```cpp
    int maxProfit(const std::vector<int>& prices)
    {
        int minPrice = INT_MAX;
        int maxProfit = 0;
        
        for (int price : prices)
        {
            if (price < minPrice)
            {
                minPrice = price;
            }
            else if (price - minPrice > maxProfit)
            {
                maxProfit = price - minPrice;
            }
        }
        return maxProfit;
    }
    ```
    

## 2. Алгоритм Кадана для maximal Subarray Problem

- **Определение:** Алгоритм Кадана – это метод для поиска непрерывного подмассива (последовательных элементов массива) с максимальной суммой в заданном массиве целых чисел.
    
- **Описание рекурсивного подхода:**
    
	$f(i)=max⁡(f(i−1)+a[i],  a[i])f(i) = \max(f(i-1) + a[i],\; a[i])$,
    
    где `a[i]` – элемент массива в позиции `i`. Это означает, что максимальный подмассив либо продолжается, либо начинается заново.
    
- **Пример кода:**
    
    ```cpp
    int kadaneAlgorithm(const std::vector<int>& arr)
    {
        int maxEndingHere = arr[0], maxSoFar = arr[0];
        for (size_t i = 1; i < arr.size(); ++i)
        {
            maxEndingHere = std::max(arr[i], maxEndingHere + arr[i]);
            maxSoFar = std::max(maxSoFar, maxEndingHere);
        }
        return maxSoFar;
    }
    ```