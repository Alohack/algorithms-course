```table-of-contents
```
# Order Statistics

## Принцип **«разделяй и властвуй»**

Это метод решения задач, при которых задача разбивается на более мелкие, в надежде, что после их решения сможем решить исходную задачу.

**Например:** `QuickSort, MergeSort` – типичные примеры "divide and conquer".

`HeapSort` – не использует "divide and conquer", а используется *"жадный"* принцип (об этом позже).

## **Порядковая статистика**

Пусть имеем массив из $n$ чисел.

**Определение:** 
> _k_-той порядковой статистикой массива называется элемент с индексом _k_ после сортировки массива _arr_. 

Причём _k_ берут по-разному $[0, n-1]$, но мы начнем с 0 (можно начать с 1).
Сортируем по возрастанию.

**Например:** *0*-ая порядковая статистика – это наименьший элемент массива, а $(n-1)$-ая порядковая статистика - это наибольший элемент массива.

### **Как найти _k_-тую порядковую статистику?**

1. Отсортировать и взять _k_-тый элемент. В лучшем случае $O(n \log n)$.
2. Делаем `make_heap`, далее _k_ раз `pop_heap`(каждый `pop_heap` - *log n* времени). $O(n + k \log n)$
3. Алгоритм, который называется`QuickSelect.` (в библиотеке алгоритмов он называется по другому: `std::nth_element`)

**Определение:** 
> $k = [\frac n 2]$ порядковая статистика называется *нижней медианой*.

Если бы $\frac n 2$ округлялось вверх она бы называлась *верхней медианой*.<br>
Вообще медианой называется средняя арифметическая нижней и верхней медиан, но нам в наших алгоритмах нужна будет лишь нижняя медиана, по этому под *медианой* будем понимать именно нижнюю медиану.

## ***QuickSelect***

Псевдокод алгоритма `QuickSelect`

```cpp
QuickSelect(arr, k)
{
    if(arr.size == 1)
        return arr[0]
    
    pivotIndex = pivot(arr); // A call to a function which chooses the pivot
    j = partition(arr, pivotIndex); // j is the new index of pivot

    if (j > k)
        return QuickSelect(arr[0, j], k); // рекурсивный вызов QuickSelect

    if (j < k)
        return QuickSelect(arr[j+1, n], k-j-1); // рекурсивный вызов QuickSelect

    return pivot;
}
```

В `QuickSelect` рекурсивно вызывается:

- если `pivotIndex > k`, то передается `arr[0,j]` и находится `k`-тая порядковая статистика;
- если `pivotIndex < k`, то передается `arr[j+1,n]` и находится `(k-j-1)`-ая порядковая статистика.

Partition требует $O(n)$ действий.
- В *худшем* случае, `pivot` всё время будет появляться на концах (например в начале, и мы будем выбирать правую часть `pivot`). Тут получится $O(n^2)$ действий по аналогии с алгоритмом `QuickSort`.
- В *лучшем* случае `pivot` всегда на середине тогда **Число сравнений** $\leq n + \frac n 2 + \frac n 4 + ... = n (1 + \frac 1 2 + \frac 1 4 + ...) = 2n$.  Сложность: $O(n)$: 


Ниже можете видеть анимацию примера работы алгоритма `QuickSelect` при котором способ выбора `pivot` случайный, то есть

```cpp
pivot(arr)
{
    return rand() % arr.size();
}
```

<p align="center">
  <img src="https://raw.githubusercontent.com/Alohack/algorithms-course/refs/heads/main/Images/QuickSelect.gif" />
</p>

Заметте, что в отличае от алгоритма `QuickSort` алгоритм `QuickSelect` рекурсивно вызывает лишь одну из частей после `partition`.

### **Утверждение:** 
Если $T(n)$ – мат. ожидание числа сравнений `QuickSelect`, то: $T(n) \leq 2n, \forall n \geq 0$ .

**Доказательство:** Вспомним доказательство `QuickSort` и составим рекуррентное соотношение для мат. ожидания числа сравнений алгоритма `QuickSelect`. В формуле снизу коэффициент суммы равен $\frac{1}{n}$ а не $\frac{2}{n}$ так как рекурсивно вызывается либо левая либо правая части `pivot` но не оба вместе.

$$
T(n)= n-1 + \frac{1}{n} \sum_{k=0}^{n-1} T(k)
$$


1. Очевидно, что при _n = 0_ сравнений не выполняется, то есть $T(1) = 0 \leq 0.$
2. Предположим, что утверждение верно для всех $k=1, 2, ..., n$.
3. Докажем для $n$.

Однако, поскольку `QuickSelect` рекурсивно вызывается только для одной части массива (левой или правой), формула будет:

$$
T(n) = (n - 1) + \frac{1}{n} \sum_{k=0}^{n-1} T(k)
$$
По предположению индукции, для всех $k < n$ имеем $T(k) \leq 2k$. 
Тогда: 
$$
\sum_{k=0}^{n-1} T(k) \leq \sum_{k=0}^{n-1} 2k = 2 \sum_{k=0}^{n-1} k = 2 \cdot \frac{(n-1)n}{2} = (n-1)n.
$$

Подставляем в формулу: 

$$
T(n) \leq (n - 1) + \frac{1}{n} \cdot (n - 1)n
$$

$$
T(n) \leq (n - 1) + (n - 1) = 2(n - 1) \leq 2n
$$

$$
T(n) \leq 2n
$$

$\blacksquare$

То есть в среднем `QuickSelect` работает за $O(n)$. Это лучше, чем использование `heap`.


> Вопрос: Но ведь если использовать `heap` для нахождения `k`-той порядковой статистики и `k` раз делать `pop_heap` то мы получаем не только `k`-тую порядковую статистику, но и первые `k-1` порядковых статистик за $О(n+klogn)$ времени, за сколько времени можн найти остальные `k-1` порядковых статистик если использовать `QuickSelect` ?

Ответ: Снова в средбен за $O(n)$, после `QuickSelect` всего лишь нужно дополнительный раз сделать `partition` использовав в качестве `pivot` `k`-тую порядковую статистику, тогда первые `k-1` порядковых статистик появятся в начале массива.

> Вопрос: Если использовать `heap` для нахождения `k`-той порядковой статистики и `k` раз делать `pop_heap` то мы  не только получаем первые `k` порядковых статистик, но еще и получаем их в отсортированном порядке за $О(n+klogn)$ времени, за сколько времени можно получить первые `k` порядковых статистик если использовать `QuickSelect`?

Ответ: Как уже сказали найти первые `k` порядковых статистик стоит $O(n)$ времени, а отсортировать их можно за $O(k \log k)$, в итоге

С использованием `heap`: $O(n+k \log n)$<br>
С использованием `QuickSelect`: $O(n+k \log k)$

И тут снова `QuickSelect` выбрал. В итоге имеем, что `heap` не годится ни для сортировки, ни для нахождения `k`-той порядковой статистики, ни для нахождения первых `k` порядковых статистик в отсортированном порядке.

> Вопрос: Где вообще нужен `heap`?

`heap` нужен, если либо мы не знаем сколько именно раз нужно делать `pop_heap` либо если данные меняются динамически. Тогда `QuickSelect` и вовсе не получится использовать. В будущем мы увидим множество алгоритмов, где используется структура `heap`.

***A можно сделать так, чтобы правильно выбирая pivot:***
- QuickSelect работал за _O(n)_
- QuickSort за _O(n log n)_ 

## Алгоритм медианы медиан

Это способ выбора `pivot` во время алгоритма `QuickSort` или `QuickSelect`, он используется при вызове функции выбора `pivot`, который например в псевдокоде `QuickSelect` вызывался на строке `pivot(arr);`. Состоит он из следующих шагов

1. Разделяем массив на подмассивы размера 5 (возможно не делится на 5, тогда будет чуть меньше 5-и, но мы предположим, что делится).
2. Из каждого подмассива выбираем медиану.
3. В массиве размера 5 медиану можно выбрать за 6 шагов. Учитываем, что слева и справа есть по два элемента.
4. Для этих _n/5_ штук медиан рекурсивно вызываем `QuickSelect` для нахождения их медианы.
5. Найденную медиану используем в качестве `pivot`.

Ниже можете видеть псевдокод

```cpp
pivot(arr) //Median of medians way of chosing pivot.
{
    std::size_t numberOfFoundMedians = 0;
    for(std::size_t i = 0; i < arr.size(); i+=5)
    {
        std::size_t leftEnd = i;
        std::size_t rightEnd = std::min(i+5, arr.size());
        std::size_t medianIndex = findMedian(leftEnd, rightEnd); // 6 comparisons at most.

        std::swap(arr[numberOfMedians], arr[medianIndex]); // We could keep all the medians
                                                           // in separate array, but it is
                                                           // better to do everything in-place.
        ++numberOfMedians;
    }
    // After this loop all the medians will be at the beginning of the array
    // with indexes in [0, numberOfMedians).

    return QuickSelect(arr[0:numberOfMedians], numberOfMedians/2); // Recursive call to QuickSelect
                                                                   // to find the median among medians
}

QuickSelect(arr, k) // Same QuickSelect as earlier.
{
    if(arr.size == 1)
        return arr[0]
    
    pivotIndex = pivot(arr); // Notice that QuickSelect calls pivot and pivot calls QuickSelect.
    j = partition(arr, pivotIndex);

    if (j > k)
        return QuickSelect(arr[0, j], k);

    if (j < k)
        return QuickSelect(arr[j+1, n], k-j-1);

    return pivot;
}

```

А ниже можете видеть пример работы алгоритма медианы медиан где сравнение происходит алфовитным порядком (Тут сразу вызвана функция `pivot`):
<p align="center">
  <img src="https://raw.githubusercontent.com/Alohack/algorithms-course/refs/heads/main/Images/MedianOfMedians.gif" />
</p>

> Замечание: На данной анимации алгоритм медианы медиан не заканчивается, далее вызывается `QuickSelect` для найденных медиан (зеленых) и находится их медиана, которая и называется медианой медиан.

### Что это дает?

Рассмотрим, что произойдет если вызвать `partition` используя медиану медиан в качестве `pivot`.<br>
Для начала заметим, что всего медиан подмассивов $\frac n 5$ штук, а медиана медиан больше чем половина медиан, то есть больше чем $\frac {n} {10}$ элементов массива.<br>
Далее, каждая медиана подмассива размера 5 больше двух элементов этого подмассива, а следовательно медиана медиан больше чем еще $2\frac {n} {10}$ эелементов массива.<br>
Таким образом медиана медиан больше чем $\frac {n} {10} + 2\frac {n} {10} = 3\frac {n} {10}$ элементов массива.<br>
Заметим, что медиана медиан также меньше чем $3\frac {n} {10}$ элементов массива, так как тут суждения относительно "больше" и "меньше" симметричны.

Учитывая все вышесказанное если произвести `partition` используя медиану медиан в качестве `pivot`, то большая из правой и левой части `pivot` не будет содержать больше $7\frac {n} {10}$ элементов.

Рассмотрим сложность алгоритма.

Обозначим через $T(n)$ число сравнений в *худшем* случае алгоритма `QuickSelect`, который выбирает `pivot` методом медианы медиан.

- Для нахождения медианы подмассива размера 5 необходимо всего 6 сравнений [(смотри тут)](https://stackoverflow.com/questions/480960/how-do-i-calculate-the-median-of-five-in-c).<br> Всего такох подмассивов $\frac n 5$ штук, следовательно будет $\frac {6n} 5$ сравнений.
- После нахождения $\frac n 5$ медиан вызывается `QuickSelect` для найденных $\frac n 5$ медиан, которая сделает $T(\frac n 5)$ сравнений в среднем.
- После того как мы найдем медиану медиан будет вызвана функция `partition`, которая сделает $n-1$ сравнений.
- Далее `QuickSelect` вызовется для одной из частей `partition`, которая как уже было сказано,<br> содержит не более $\frac{7n}{10}$ элементов и будет произведено $T(\frac{7n}{10})$ сравнений.

Таким образом

$$
T(n) = \frac{6n}{5} + T\left(\frac{n}{5}\right) + (n - 1) + T\left(\frac{7n}{10}\right)
$$

После выбора `pivot` он точно больше чем _n/10_ медиан (он медиан медиан, а медианов _n/5_). Выбранная медиана медиан будет больше чем _3n/10_ элементов и меньше чем _3n/10_ элементов.

### **Утверждение:** 
$\exists c > 0$, такое что $T(n) ≤ c·n$

**Доказательство:**
 По индукции:
1. Предположим утверждение верно для $\forall k < n$.
2. Докажем для _n_.

Если утверждение верно для $\forall k < n$ => верно для $\frac n 5, \frac {7n} {10}$

$$
T(n) = \frac{6n}{5} + T\left(\frac{n}{5}\right) + (n - 1) + T\left(\frac{7n}{10}\right) \leq \frac{6n}{5} + \frac{cn}{5} + n + \frac{7cn}{10} = n\left(\frac{6}{5} + \frac{c}{5} + 1 + \frac{7c}{10}\right)
$$

В самом оптимальном случае должны взять $c$ так, чтобы:

$$
\frac{6}{5} + \frac{c}{5} + 1 + \frac{7c}{10} = c
$$

В итоге имеем $T(n) ≤ 22n$ (22 - наименьшее из тех _c_, для которых $T(n) \leq c\cdot n$)

Таким образом мы можем обеспечить, чтобы `QuickSelect` работал бы в худшем за $O(n)$, а `QuickSort` в худшем случае за $O(n \log n)$, но в среднем все ухудшиловс в 11 раз.

Медиана медиан - это явный пример того, что ассимптотическая сложность в худшем случае - это еще не показательный критерий эффективности алгоритма, надо также учитывать и ассимптотическую константу и сложность в среднем случае.

Но остался неотвеченным

> Вопрос: Почему нужно разделять массив на подмассивы размера именно 5?

Ответ: Для начала поймем, что чем меньше мы берем массив тем меньше действий уйдет на нахождение медиан подмассивов, что сохранит нам число шагов с умножением на константу, так что перефразируем вопрос:

> Вопрос: Нельзя ли разделить массив на подмассивы размера меньше 5?

Ну для начала поймем, что если подбирать массивы четной длины, то после выбора нижних медиан подмассив будет разбит несимметрично. Например если подобрать разнер подмассива 4, то меньше медианы будет только 1 элемент (1 элемент будет также в случае разделения на 3), а больше него 2 элемента (2 элемента было в случае разбиения на 5). Таким образом худшая сложность разбиения на массивы четной длины будет эквивалентна разбиению массива нечетной длины.

Вопрос можно еще уточнить:

> Вопрос: Нельзя ли разделить массив на подмассивы размера 1 или 3?

Разбить массив на подмассивы размера 1 эквивалентно тому, чтобы не разбивать массив вовсе, в итоге остался один вариант и можно перейти к ответу на следующий вопрос:

> Вопрос: Нельзя ли разделить массив на подмассивы размера 3?

Ответ: Рассмотрим число шагов в случае разбиения массива на части размера 3 в худшем случае:

- Для нахождения медианы среди трех чисел нужны лишь 3 сравнения, а подмассивов размера 3 у нас будет $\frac n 3$ штук, таким образом $3\cdot \frac n 3 = n$ действий уйдет на нахождения медиан подмассивов.
- После нахождения $\frac n 3$ медиан вызывается `QuickSelect` для найденных $\frac n 3$ медиан, которая сделает $T(\frac n 3)$ сравнений в среднем.
- После того как мы найдем медиану медиан будет вызвана функция `partition`, которая сделает $n-1$ сравнений.
- Далее `QuickSelect` вызовется для одной из частей `partition`, которая в этот раз,<br> содержит не более $\frac{2n}{3}$ элементов и будет произведено $T(\frac{2n}{3})$ сравнений.

Итак имеем:

$$
T(n) = n + T\left(\frac{n}{3}\right) + (n - 1) + T\left(\frac{2n}{3}\right)
$$

>Вопрос: Существует ли такое $c>0$ чтобы
>
> $$
> T(n) \leq c \cdot n,  \forall n \geq 0?
> $$

Ответ: предположим, что существует, то есть

$$
\exists c > 0, T(n) \leq c \cdot n,  \forall n \geq 0.
$$

Тогда

$$
T(n) \leq n + \frac{cn}{3} + n + \frac{2cn}{3} = (2+c)\cdot n
$$

Следовательно, если попытаться выбрать наименьший из таких $c > 0$ то у нас получится

$$
(2+c)\cdot n = c \cdot n
$$

Пришли к противоречию, следовательно такого $c > 0$ не существует.

Но оказывается, что

$$
\exists c > 0, T(n) \leq c \cdot n \log_2 n,  \forall n \geq 0.
$$

Докажите сами.

То есть если выбрать подмассивы размера $3$ то у нас получится сложность не $O(n)$, а $O(n \log n)$ и выбор размера подмассивов равным $5$ является оптимальным.