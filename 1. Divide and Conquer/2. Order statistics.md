```table-of-contents
```
# Order Statistics

## Принцип **«разделяй и властвуй»**

Это метод решения задач, при которых задача разбивается на более мелкие, в надежде, что после их решения сможем решить исходную задачу.

**Например:** `QuickSort, MergeSort` – типичные примеры "divide and conquer".

`HeapSort` – не использует "divide and conquer", а используется *"жадный"* принцип (об этом позже).

## **Порядковая статистика**

Пусть имеем массив из $n$ чисел.

**Определение:** 
> _k_-той порядковой статистикой массива называется элемент с индексом _k_ после сортировки массива _arr_. 

Причём _k_ берут по-разному $[0, n-1]$, но мы начнем с 0 (можно начать с 1).
Сортируем по возрастанию.

**Например:** *0*-ая порядковая статистика – это наименьший элемент массива, а $(n-1)$-ая порядковая статистика - это наибольший элемент массива.

### **Как найти _k_-тую порядковую статистику?**

1. Отсортировать и взять _k_-тый элемент. В лучшем случае $O(n \log n)$.
2. Делаем `make_heap`, далее _k_ раз `pop_heap`(каждый `pop_heap` - *log n* времени). $O(n + k \log n)$
3. Алгоритм, который называется`QuickSelect.` (в библиотеке алгоритмов он называется по другому: `std::nth_element`)

**Определение:** 
> $k = [\frac n 2]$ порядковая статистика называется *нижней медианой*.

Если бы $\frac n 2$ округлялось вверх она бы называлась *верхней медианой*.<br>
Вообще медианой называется средняя арифметическая нижней и верхней медиан, но нам в наших алгоритмах нужна будет лишь нижняя медиана, по этому под *медианой* будем понимать именно нижнюю медиану.

## ***QuickSelect***

Псевдокод алгоритма `QuickSelect`

```cpp
QuickSelect(arr, k)
{
    if(arr.size == 1)
        return arr[0]
    
    pivotIndex = pivot(arr); // A call to a function which chooses the pivot
    j = partition(arr, pivotIndex); // j is the new index of pivot

    if (j > k)
        return QuickSelect(arr[0, j], k); // рекурсивный вызов QuickSelect

    if (j < k)
        return QuickSelect(arr[j+1, n], k-j-1); // рекурсивный вызов QuickSelect

    return pivot;
}
```

В `QuickSelect` рекурсивно вызывается:

- если `pivotIndex > k`, то передается `arr[0,j]` и находится `k`-тая порядковая статистика;
- если `pivotIndex < k`, то передается `arr[j+1,n]` и находится `(k-j-1)`-ая порядковая статистика.

Partition требует $O(n)$ действий.
- В *худшем* случае, `pivot` всё время будет появляться на концах (например в начале, и мы будем выбирать правую часть `pivot`). Тут получится *$O(n^2)$* действий по аналогии с алгоритмом `QuickSort`.
- В *лучшем* случае `pivot` всегда на середине тогда **Число сравнений** $\leq n + \frac n 2 + \frac n 4 + ... = n (1 + \frac 1 2 + \frac 1 4 + ...) = 2n$.  Сложность: _$O(n)$_: 


Ниже можете видеть анимацию примера работы алгоритма `QuickSelect` при котором способ выбора `pivot` случайный, то есть

```cpp
pivot(arr)
{
    return rand() % arr.size();
}
```

<p align="center">
  <img src="https://raw.githubusercontent.com/Alohack/algorithms-course/refs/heads/main/Images/QuickSelect.gif" />
</p>

Заметте, что в отличае от алгоритма `QuickSort` алгоритм `QuickSelect` рекурсивно вызывает лишь одну из частей после `partition`.

### **Утверждение:** 
Если $T(n)$ – мат. ожидание числа сравнений `QuickSelect`, то: $T(n)≤2n$ для $\forall n≥0$.

**Доказательство:** Вспомним доказательство `QuickSort` и составим рекуррентное соотношение для мат. ожидания числа сравнений алгоритма `QuickSelect`. В формуле снизу коэффициент суммы равен $\frac{1}{n}$ а не $\frac{2}{n}$ так как рекурсивно вызывается либо левая либо правая части `pivot` но не оба вместе.

$$
T(n)= n-1 + \frac{1}{n} \sum_{k=0}^{n-1} T(k)
$$


1. Очевидно, что при _n = 0_ сравнений не выполняется, то есть $T(1) = 0 \leq 0.$
2. Предположим, что утверждение верно для всех $k=1, 2, ..., n$.
3. Докажем для $n$.

Однако, поскольку `QuickSelect` рекурсивно вызывается только для одной части массива (левой или правой), формула будет:

$$
T(n) = (n - 1) + \frac{1}{n} \sum_{k=0}^{n-1} T(k)
$$
По предположению индукции, для всех $k < n$ имеем $T(k) \leq 2k$. 
Тогда: 
$$
\sum_{k=0}^{n-1} T(k) \leq \sum_{k=0}^{n-1} 2k = 2 \sum_{k=0}^{n-1} k = 2 \cdot \frac{(n-1)n}{2} = (n-1)n.
$$

Подставляем в формулу: 

$$
T(n) \leq (n - 1) + \frac{1}{n} \cdot (n - 1)n\\
T(n) \leq (n - 1) + (n - 1) = 2(n - 1) \leq 2n\\
T(n) \leq 2n
$$

$\blacksquare$

То есть в среднем `QuickSelect` работает за $O(n)$. Это лучше, чем использование `heap`.


> Вопрос: Но ведь если использовать `heap` для нахождения `k`-той порядковой статистики и `k` раз делать `pop_heap` то мы получаем не только `k`-тую порядковую статистику, но и первые `k-1` порядковых статистик за $О(n+klogn)$ времени, за сколько времени можн найти остальные `k-1` порядковых статистик если использовать `QuickSelect` ?

Ответ: Снова в средбен за $O(n)$, после `QuickSelect` всего лишь нужно дополнительный раз сделать `partition` использовав в качестве `pivot` `k`-тую порядковую статистику, тогда первые `k-1` порядковых статистик появятся в начале массива.

> Вопрос: Если использовать `heap` для нахождения `k`-той порядковой статистики и `k` раз делать `pop_heap` то мы  не только получаем первые `k` порядковых статистик, но еще и получаем их в отсортированном порядке за $О(n+klogn)$ времени, за сколько времени можно получить первые `k` порядковых статистик если использовать `QuickSelect`?

Ответ: Как уже сказали найти первые `k` порядковых статистик стоит $O(n)$ времени, а отсортировать их можно за $O(k \log k)$, в итоге

С использованием `heap`: $O(n+k \log n)$<br>
С использованием `QuickSelect`: $O(n+k \log k)$

И тут снова `QuickSelect` выбрал. В итоге имеем, что `heap` не годится ни для сортировки, ни для нахождения `k`-той порядковой статистики, ни для нахождения первых `k` порядковых статистик в отсортированном порядке.

> Вопрос: Где вообще нужен `heap`?

`heap` нужен, если либо мы не знаем сколько именно раз нужно делать `pop_heap` либо если данные меняются динамически. Тогда `QuickSelect` и вовсе не получится использовать. В будущем мы увидим множество алгоритмов, где используется структура `heap`.

***A можно сделать так, чтобы правильно выбирая pivot:***
- QuickSelect работал за _O(n)_
- QuickSort за _O(n log n)_ 

## Алгоритм медианы медиан

Это способ выбора `pivot` во время алгоритма `QuickSort` или `QuickSelect`, он используется при вызове функции выбора `pivot`, который например в псевдокоде `QuickSelect` вызывался на строке `pivot(arr);`. Состоит он из следующих шагов

1. Разделяем массив на подмассивы размера 5 (возможно не делится на 5, тогда будет чуть меньше 5-и, но мы предположим, что делится).
2. Из каждого подмассива выбираем медиану.
3. В массиве размера 5 медиану можно выбрать за 6 шагов. Учитываем, что слева и справа есть по два элемента.
4. Для этих _n/5_ штук медиан рекурсивно вызываем `QuickSelect` для нахождения их медианы.
5. Найденную медиану используем в качестве `pivot`.

Ниже можете видеть псевдокод

```cpp
pivot(arr) //Median of medians way of chosing pivot.
{
    std::size_t numberOfFoundMedians = 0;
    for(std::size_t i = 0; i < arr.size(); i+=5)
    {
        std::size_t leftEnd = i;
        std::size_t rightEnd = std::min(i+5, arr.size());
        std::size_t medianIndex = findMedian(leftEnd, rightEnd); // 6 comparisons at most.

        std::swap(arr[numberOfMedians], arr[medianIndex]); // We could keep all the medians
                                                           // in separate array, but it is
                                                           // better to do everything in-place.
        ++numberOfMedians;
    }
    // After this loop all the medians will be at the beginning of the array
    // with indexes in [0, numberOfMedians).

    return QuickSelect(arr[0:numberOfMedians], numberOfMedians/2); // Recursive call to QuickSelect
                                                                   // to find the median among medians
}

QuickSelect(arr, k) // Same QuickSelect as earlier.
{
    if(arr.size == 1)
        return arr[0]
    
    pivotIndex = pivot(arr); // Notice that QuickSelect calls pivot and pivot calls QuickSelect.
    j = partition(arr, pivotIndex);

    if (j > k)
        return QuickSelect(arr[0, j], k);

    if (j < k)
        return QuickSelect(arr[j+1, n], k-j-1);

    return pivot;
}

```

А ниже можете видеть пример работы алгоритма медианы медиан где сравнение происходит алфовитным порядком (Тут сразу вызвана функция `pivot`):
<p align="center">
  <img src="https://raw.githubusercontent.com/Alohack/algorithms-course/refs/heads/main/Images/MedianOfMedians.gif" />
</p>

> Замечание: На данной анимации алгоритм медианы медиан не заканчивается, далее вызывается `QuickSelect` для найденных медиан (зеленых) и находится их медиана, которая и называется медианой медиан.

### Что это дает?

Рассмотрим, что произойдет если вызвать `partition` используя медиану медиан в качестве `pivot`.<br>
Для начала заметим, что всего медиан подмассивов $\frac n 5$ штук, а медиана медиан больше чем половина медиан, то есть больше чем $\frac {n} {10}$ элементов массива.<br>
Далее, каждая медиана подмассива размера 5 больше двух элементов этого подмассива, а следовательно медиана медиан больше чем еще $2\frac {n} {10}$ эелементов массива.<br>
Таким образом медиана медиан больше чем $\frac {n} {10} + 2\frac {n} {10} = 3\frac {n} {10}$ элементов массива.<br>
Заметим, что медиана медиан также меньше чем $3\frac {n} {10}$ элементов массива, так как тут суждения относительно "больше" и "меньше" симметричны.

Учитывая все вышесказанное если произвести `partition` используя медиану медиан в качестве `pivot`, то большая из правой и левой части `pivot` не будет содержать больше $7\frac {n} {10}$ элементов.

Рассмотрим сложность алгоритма.

Обозначим через $T(n)$ число сравнений в *худшем* случае алгоритма `QuickSelect`, который выбирает `pivot` методом медианы медиан.

- Для нахождения медианы подмассива размера 5 необходимо всего 6 сравнений [(смотри тут)](https://stackoverflow.com/questions/480960/how-do-i-calculate-the-median-of-five-in-c). Всего такох подмассивов $\frac n 5$ штук, следовательно будет $\frac {6n} 5$ сравнений.
- После нахождения $\frac n 5$ медиан вызывается `QuickSelect` для найденных $\frac n 5$ медиан, которая сделает $T(\frac n 5)$ сравнений в среднем.
- После того как мы найдем медиану медиан будет вызвана функция `partition`, которая сделает $n-1$ сравнений.
- Далее `QuickSelect` вызовется для одной из частей `partition`, которая как уже было сказано, не содержит более $\frac{7n}{10}$ элементов и будет произведено $T(\frac{7n}{10})$ сравнений.

Таким образом

$$
T(n) = \frac{6n}{5} + T\left(\frac{n}{5}\right) + (n - 1) + T\left(\frac{7n}{10}\right)
$$

После выбора `pivot` он точно больше чем _n/10_ медиан (он медиан медиан, а медианов _n/5_). Выбранная медиана медиан будет больше чем _3n/10_ элементов и меньше чем _3n/10_ элементов.

### **Утверждение:** 
$\exists c > 0$, такое что $T(n) ≤ c·n$

**Доказательство:**
 По индукции:
1. Предположим утверждение верно для $\forall k < n$.
2. Докажем для _n_.

Если утверждение верно для $\forall k < n$ => верно для $\frac n 5, \frac {7n} {10}$

$$
T(n) = \frac{6n}{5} + T\left(\frac{n}{5}\right) + (n - 1) + T\left(\frac{7n}{10}\right) \leq \frac{6n}{5} + \frac{cn}{5} + n + \frac{7cn}{10} = n\left(\frac{6}{5} + \frac{c}{5} + 1 + \frac{7c}{10}\right)
$$

В самом оптимальном случае должны взять $c$ так, чтобы:

$$
\frac{6}{5} + \frac{c}{5} + 1 + \frac{7c}{10} = c
$$

В итоге имеем $T(n) ≤ 22n$ (22 - наименьшее из тех _c_, для которых $T(n) \leq c\cdot n$)

Таким образом мы можем обеспечить, чтобы `QuickSelect` работал бы в худшем за $O(n)$, а `QuickSort` в худшем случае за $O(n \log n)$, но в среднем все ухудшиловс в 11 раз.

Медиана медиан - это явный пример того, что ассимптотическая сложность в худшем случае - это еще не показательный критерий эффективности алгоритма, надо также учитывать и ассимптотическую константу и сложность в среднем случае.
