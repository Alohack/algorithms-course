```table-of-contents
```
# Order Statistics

## Принцип **«разделяй и властвуй»**

Это метод решения задач, при которых задача разбивается на более мелкие, в надежде, что после их решения сможем решить исходную задачу.

**Например:** `QuickSort, MergeSort` – типичные примеры "divide and conquer".

`HeapSort` – не использует "divide and conquer", а используется *"жадный"* принцип (об этом позже).

## **Порядковая статистика**

Пусть имеем массив из $n$ чисел.

**Определение:** 
> _k_-той порядковой статистикой массива называется элемент с индексом _k_ после сортировки массива _arr_. 

Причём _k_ берут по-разному $[0, n-1]$, но мы начнем с 0 (можно начать с 1).
Сортируем по возрастанию.

**Например:** *0*-ая порядковая статистика – это наименьший элемент массива, а $(n-1)$-ая порядковая статистика - это наибольший элемент массива.

### **Как найти _k_-тую порядковую статистику?**

1. Отсортировать и взять _k_-тый элемент. В лучшем случае $O(n \log n)$.
2. Делаем `make_heap`, далее _k_ раз `pop_heap`(каждый `pop_heap` - *log n* времени). $O(n + k \log n)$
3. Алгоритм, который называется`QuickSelect.` (в библиотеке алгоритмов он называется по другому: `std::nth_element`)

**Определение:** 
> $k = [\frac n 2]$ порядковая статистика называется *нижней медианой*.

Если бы $\frac n 2$ округлялось вверх она бы называлась *верхней медианой*.<br>
Вообще медианой называется средняя арифметическая нижней и верхней медиан, но нам в наших алгоритмах нужна будет лишь нижняя медиана, по этому под *медианой* будем понимать именно нижнюю медиану.

## ***QuickSelect***

Псевдокод алгоритма `QuickSelect`

```cpp
QuickSelect(arr, k)
{
    if(arr.size == 1)
        return arr[0]
    
    pivotIndex = pivot(arr); // A call to a function which chooses the pivot
    j = partition(arr, pivotIndex); // j is the new index of pivot

    if (j > k)
        return QuickSelect(arr[0, j], k); // рекурсивный вызов QuickSelect

    if (j < k)
        return QuickSelect(arr[j+1, n], k-j-1); // рекурсивный вызов QuickSelect

    return pivot;
}
```

В `QuickSelect` рекурсивно вызывается:

- если `pivotIndex > k`, то передается `arr[0,j]` и та же порядковая статистика;
- если `pivotIndex < k`, то передается `arr[j+1,n]` и `(k-j-1)`-ая порядковая статистика.

Partition требует $O(n)$ действий.
- В *худшем* случае, `pivot` всё время будет появляться на концах (например в начале, и мы будем выбирать правую часть `pivot`). Тут получится *$O(n^2)$* действий по аналогии с алгоритмом `QuickSort`.
- В *лучшем* случае `pivot` всегда на середине тогда **Число сравнений** $\leq n + \frac n 2 + \frac n 4 + ... = n (1 + \frac 1 2 + \frac 1 4 + ...) = 2n$.  Сложность: _$O(n)$_: 


Ниже можете видеть анимацию примера работы алгоритма `QuickSelect`

<p align="center">
  <img src="https://raw.githubusercontent.com/Alohack/algorithms-course/refs/heads/main/Images/QuickSelect.gif" />
</p>

### **Утверждение:** 
Если $T(n)$ – мат. ожидание числа сравнений `QuickSelect`, то: $T(n)≤2n$ для $\forall n≥0$.

**Доказательство:** Вспомним доказательство `QuickSort` и составим рекуррентное соотношение для мат. ожидания числа сравнений алгоритма `QuickSelect`. В формуле снизу коэффициент суммы равен $\frac{1}{n}$ а не $\frac{2}{n}$ так как рекурсивно вызывается либо левая либо правая части `pivot` но не оба вместе.

$$
T(n)= n-1 + \frac{1}{n} \sum_{k=0}^{n-1} T(k)
$$


1. Очевидно, что при _n = 0_ сравнений не выполняется, то есть $T(1) = 0 \leq 0.$
2. Предположим, что утверждение верно для всех $k=1, 2, ..., n$.
3. Докажем для $n$.

Однако, поскольку `QuickSelect` рекурсивно вызывается только для одной части массива (левой или правой), формула будет:

$$
T(n) = (n - 1) + \frac{1}{n} \sum_{k=0}^{n-1} T(k)
$$
По предположению индукции, для всех $k < n$ имеем $T(k) \leq 2k$. 
Тогда: 
$$
\sum_{k=0}^{n-1} T(k) \leq \sum_{k=0}^{n-1} 2k = 2 \sum_{k=0}^{n-1} k = 2 \cdot \frac{(n-1)n}{2} = (n-1)n.
$$

Подставляем в формулу: 
$$
T(n) \leq (n - 1) + \frac{1}{n} \cdot (n - 1)n
$$

$$
T(n) \leq (n - 1) + (n - 1) = 2(n - 1) \leq 2n
$$

$$
T(n) \leq 2n
$$
$\blacksquare$

То есть в среднем `QuickSelect` работает за $O(n)$. Это лучше, чем использование `heap`.


> Вопрос: Но ведь если использовать `heap` для нахождения `k`-той порядковой статистики и `k` раз делать `pop_heap` то мы получаем не только `k`-тую порядковую статистику, но и первые `k-1` порядковых статистик за $О(n+klogn)$ времени, за сколько времени можн найти остальные `k-1` порядковых статистик если использовать `QuickSelect` ?

Ответ: Снова в средбен за $O(n)$, после `QuickSelect` всего лишь нужно дополнительный раз сделать `partition` использовав в качестве `pivot` `k`-тую порядковую статистику, тогда первые `k-1` порядковых статистик появятся в начале массива.

> Вопрос: Если использовать `heap` для нахождения `k`-той порядковой статистики и `k` раз делать `pop_heap` то мы  не только получаем первые `k` порядковых статистик, но еще и получаем их в отсортированном порядке за $О(n+klogn)$ времени, за сколько времени можно получить первые `k` порядковых статистик если использовать `QuickSelect`?

Ответ: Как уже сказали найти первые `k` порядковых статистик стоит $O(n)$ времени, а отсортировать их можно за $O(k \log k)$, в итоге

С использованием `heap`: $O(n+k \log n)$<br>
С использованием `QuickSelect`: $O(n+k \log k)$

И тут снова `QuickSelect` выбрал. В итоге имеем, что `heap` не годится ни для сортировки, ни для нахождения `k`-той порядковой статистики, ни для нахождения первых `k` порядковых статистик в отсортированном порядке.

> Вопрос: Где вообще нужен `heap`?

`heap` нужен, если либо мы не знаем сколько именно раз нужно делать `pop_heap` либо если данные меняются динамически. Тогда `QuickSelect` и вовсе не получится использовать. В будущем мы увидим множество алгоритмов, где используется структура `heap`.

***A можно сделать так, чтобы правильно выбирая pivot:***
- QuickSelect работал за _O(n)_
- QuickSort за _O(n log n)_ 

## Алгоритм медианы медиан

Это способ выбора `pivot` во время алгоритма `QuickSort` или `QuickSelect`.

1. Разделяем массив на подмассивы размера 5 (возможно не делится на 5, тогда будет чуть меньше 5-и, но мы предположим, что делится, *почему именно 5?* смотрите в слайдах).
2. Из каждого подмассива выбираем медиану.
3. В массиве размера 5 медиану можно выбрать за 6 шагов. Учитываем, что слева и справа есть по два элемента.
4. Для этих _n/5_ штук медиан рекурсивно вызываем `QuickSelect` для нахождения их медианы.
5. Найденную медиану используем в качестве `pivot`.

### Что это дает?

Рассмотрим сложность алгоритма.

Обозначим через _T(n)_ число сравнений в *худшем* случае алгоритма `QuickSelect`, который выбирает `pivot` методом медианы медиан. Этот алгоритм использует *двойную рекурсию*:
6 действий для нахождения медиан, `QuickSelect` вызывает алгоритм медианы медиан, а алгоритм медианы медиан вызывает `QuickSelect`.
$$
T(n) = \frac{6n}{5} + T\left(\frac{n}{5}\right) + T\left(\frac{7n}{10}\right)
$$

После выбора `pivot` он точно больше чем _n/10_ медиан (он медиан медиан, а медианов _n/5_). Выбранная медиана медиан будет больше чем _3n/10_ элементов и меньше чем _3n/10_ элементов.

### **Утверждение:** 
$\exists c > 0$, такое что $T(n) ≤ c·n$

**Доказательство:**
 По индукции:
1. Предположим утверждение верно для $\forall k < n$.
2. Докажем для _n_.

Если утверждение верно для $\forall k < n$ => верно для $\frac n 5, \frac {7n} {10}$

$$T(n) = \frac{6n}{5} + T\left(\frac{n}{5}\right) + T\left(\frac{7n}{10}\right) \leq \frac{6n}{5} + \frac{cn}{5} + \frac{7cn}{10} = n\left(\frac{6}{5} + \frac{c}{5} + \frac{7c}{10}\right)$$
В самом оптимальном случае должны взять _c_ так, чтобы:

$$\frac{6}{5} + \frac{c}{5} + \frac{7c}{10} = c$$

В итоге имеем $T(n) ≤ 12n$ (12 - наименьшее из тех _c_, для которых $T(n) \leq c\cdot n$. В среднем все в 6 раз ухудшилось).




```py
if (A > B)
    swap A, B
if (C > D)
    swap C, D
if (A > C)
    swap A, C
    swap B, D 

if (E > C)
    if (E > D)  # A C D E
        if (B > D)
            if (B > E)
                return (A, C, D, E, B)
            else
                return (A, C, D, B, E)
         else
            if (B < C)
                return (A, B, C, D, E)
            else
                return (A, C, B, D, E)

    else  # A C E D
        if (B > E)
            if (B > D)
                return (A, C, E, D, B)
            else
                return (A, C, E, B, D)
         else
            if (B < C)
                return (A, B, C, E, D)
            else
                return (A, C, B, E, D)
else
    if (E < A)  # E A C D
        if (B > C)
            if (B > D)
                return (E, A, C, D, B)
            else
                return (E, A, C, B, D)
         else
             return (E, A, B, C, D)

    else  # A E C D
        if (B > C)
            if (B > D)
                return (A, E, C, D, B)
            else
                return (A, E, C, B, D)
         else
            if (B < E)
                return (A, B, E, C, D)
            else
                return (A, E, B, C, D)
```
